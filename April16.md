## RustSBI
​**​类比​**​：就像电脑的 BIOS 系统，但更轻量、更安全。
1. ​**​开机时的“引导员”​**​：电脑通电后，RustSBI 会​**​初始化硬件​**​（如内存、CPU），然后像接力赛一样把控制权交给操作系统内核
2. ​**​运行时的“服务员”​**​：操作系统需要关机、输出字符或计时时，只需通过一条指令（`ecall`）呼叫 RustSBI，它就会代为操作硬件，类似服务员帮你点单
## yield 系统调用
​​
可以理解为 ​**​“主动让座”​**​，就像公交车上的乘客主动站起来说：“我现在不赶时间，座位让给更需要的人吧！”。它的核心作用是让当前运行的任务主动放弃 CPU，给其他任务运行的机会。
**yield 就像对操作系统说：“你先帮别人吧，我等等再来”​**​。它让多任务协作更流畅，是程序员在并发编程中“友好社交”的关键动作。

## 任务切换

任务切换就像 ​**​游戏存档与读档​**​，核心是保存当前任务的运行状态，再加载另一个任务的存档继续玩
1. ​**​任务上下文 (TaskContext) = 游戏存档​**​
    ```rust
    struct TaskContext { // 存档包含三个关键要素
        ra: 回家地址（存档后要从哪里继续玩），
        sp: 当前背包位置（内核栈指针），
        s0~s11: 背包里的12件重要道具（寄存器状态）
    }
    ```
2. ​**​__switch 函数 = 存档管理员​**​
- 当你喊：“管理员，我要换人玩啦！”
- 管理员（__switch）会做两件事：
	- 1️⃣ ​**​存当前存档​**​：把你的背包位置、回家地址、道具保存到储物柜（a0指向的内存）
	- 2️⃣ ​**​取新存档​**​：从另一个储物柜（a1指向的内存）取出下个玩家的存档，覆盖当前状态


假设有三个任务交替运行：

1. ​**​任务A​**​ 调用 `yield()` → 触发 __switch
    - 保存A的存档到储物柜1
    - 加载任务B的存档（储物柜2）
2. ​**​任务B​**​ 运行一段时间后调用 `yield()`
    - 保存B的存档到储物柜2
    - 加载任务C的存档（储物柜3）
3. ​**​任务C​**​ 运行后切回A
    - 保存C的存档到储物柜3
    - 重新加载A的存档（储物柜1）

整个过程就像三个玩家轮流使用同一台游戏机，每次换人都能完美恢复自己的游戏进度。


## ch3终章
[ch3 by 7qing · Pull Request #6 · LearningOS/os-rcore-classroom-2025s-rcore-rCore-Camp-Code-2025S (github.com)](https://github.com/LearningOS/os-rcore-classroom-2025s-rcore-rCore-Camp-Code-2025S/pull/6/files?short_path=4fd8d82#diff-4fd8d8291f4e4a18241f0535bbcee20e7d4f7da14e95aeafec2ab9c11119c297)

对着看，对着抄总算搞定了。