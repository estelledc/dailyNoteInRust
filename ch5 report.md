## 概览


本次实验主要围绕操作系统内核的进程管理与调度机制进行了修改和完善。具体来说，我实现了进程的创建、切换、退出以及等待等功能。通过引入进程控制块（PCB）来管理进程状态，并利用上下文切换保存和恢复进程的运行环境，实现了多进程的并发执行。

在调度算法方面，采用了简单的轮转调度（Round Robin），保证各进程能够公平地获得CPU时间片。进程的退出与回收机制也得到了完善，父进程可以通过等待子进程结束并回收其资源，避免了僵尸进程的产生。

这些修改提升了操作系统对多进程的支持能力，为后续实现更复杂的功能（如进程间通信、同步等）打下了基础。

---


## stride 算法深入
### stride 算法原理

Stride（步进）算法，是一种常用于任务调度与资源分配（尤其是操作系统中的 CPU 共享）中的公平调度算法。它通过分配不同比例的“步长（stride）”值，实现任务的近似比例公平调度。下面简要介绍其原理：

#### Stride 算法基本思想

- 每个进程（或任务）有一个对应的“份额”（share），份额越大，表示希望获得越多的资源（如 CPU 时间）。
- 对每个进程分配一个 stride 步长，计算公式为：
  $$
  \text{stride}_i = \frac{\text{常数}}{\text{share}_i}
  $$
  一般常数可以选用一个大的整数，比如 $10\,000$。
- 每个进程维护一个 pass 值，初始为 0。

#### 调度过程

1. **选择调度对象**：每次调度时，选择 pass 值最小的进程运行。
2. **更新 pass 值**：进程运行后，将其 pass 增加对应的 stride：$\text{pass}_i = \text{pass}_i + \text{stride}_i$。
3. 重复上述过程。

#### 直观理解

- 份额多的任务 stride 小，pass 增长慢，因此更频繁获得调度机会。
- 份额少的任务 stride 大，pass 增长快，因此调度频率低。
- 随着时间推移，任务被调度的次数与其份额成正比，实现近似的比例公平。


### Question
两个 pass = 10 的进程，使用 8bit 无符号整形储存 stride， p1.stride = 255, p2.stride = 250，在 p2 执行一个时间片后，理论上下一次应该 p1 执行。

- 实际情况是轮到 p1 执行吗？为什么？
	不是。用有限位数（如 8 位）存储 `stride` 时，值会溢出（如 `250 + 10 = 260` 溢出为 `4`）。

我们之前要求进程优先级 >= 2 其实就是为了解决这个问题。可以证明， **在不考虑溢出的情况下** , 在进程优先级全部 >= 2 的情况下，如果严格按照算法执行，那么 STRIDE_MAX – STRIDE_MIN <= BigStride / 2。

- 为什么？尝试简单说明（不要求严格证明）。
	假设 BigStride = 255，两个进程的优先级均为 2（Pass = 127）：
	- ​**​初始状态​**​：A.stride = 0，B.stride = 0 → 差值为 0。
	- ​**​第一次调度 A​**​：A.stride = 127，B.stride = 0 → 差值 127（≤ 127.5）。
	- ​**​第二次调度 B​**​：B.stride = 127，A.stride = 127 → 差值 0。
	- ​**​第三次调度 A​**​：A.stride = 254，B.stride = 127 → 差值 127（≤ 127.5）。

- 已知以上结论，**考虑溢出的情况下**，可以为 Stride 设计特别的比较器，让 BinaryHeap<Stride> 的 pop 方法能返回真正最小的 Stride。补全下列代码中的 `partial_cmp` 函数，假设两个 Stride 永远不会相等。

```rust
use core::cmp::Ordering;

const BIG_STRIDE: u64 = 255;  // 假设 BigStride = 255（8位）
const HALF_STRIDE: u64 = BIG_STRIDE / 2;  // 127

struct Stride(u64);

impl PartialOrd for Stride {
    fn partial_cmp(&self, other: &Self) -> Option<Ordering> {
        let a = self.0;
        let b = other.0;
        
        // 计算环形差值 (b - a) mod 256
        let diff = b.wrapping_sub(a) % (BIG_STRIDE + 1);
        
        // 判断差值是否在半周期内
        if diff <= HALF_STRIDE {
            // 差值在半周期内，说明 a 的步长更小
            Some(Ordering::Less)
        } else {
            // 差值超过半周期，说明 a 的步长实际更大
            Some(Ordering::Greater)
        }
    }
}

impl PartialEq for Stride {
    fn eq(&self, other: &Self) -> bool {
        false  // 假设 Stride 值永不相等
    }
}
```



## 荣誉准则

在完成本次实验的过程（含此前学习的过程）中，我曾分别与 以下各位 就（与本次实验相关的）以下方面做过交流，还在代码中对应的位置以注释形式记录了具体的交流对象及内容：

none

此外，我也参考了 以下资料 ，还在代码中对应的位置以注释形式记录了具体的参考来源及内容：

https://github.com/LearningOS/2025s-rcore-liu0fanyi/

1. 我独立完成了本次实验除以上方面之外的所有工作，包括代码与文档。 我清楚地知道，从以上方面获得的信息在一定程度上降低了实验难度，可能会影响起评分。

2. 我从未使用过他人的代码，不管是原封不动地复制，还是经过了某些等价转换。 我未曾也不会向他人（含此后各届同学）复制或公开我的实验代码，我有义务妥善保管好它们。 我提交至本实验的评测系统的代码，均无意于破坏或妨碍任何计算机系统的正常运转。 我清楚地知道，以上情况均为本课程纪律所禁止，若违反，对应的实验成绩将按“-100”分计。